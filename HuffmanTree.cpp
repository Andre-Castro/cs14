#include "HuffmanTree.h"

//-----------------------------------------------------------------------------
// Constructs a Huffman encoding given a list of symbols and matching
// frequencies. It is assumed that the index of the symbol matches the index of
// the symbol's frequency.
//
// INPUT
// alphabet: The characters that appear in the alphabet.
// frequencies: The frequencies of the characters.
//
// RETURN VALUE
// N/A
//
// SIDE-EFFECTS
// The member variable root will point to the root of the Huffman tree.
// The member variable symbolMap will populated.
//-----------------------------------------------------------------------------
HuffmanTree::HuffmanTree(const std::vector<char>& alphabet,
                         const std::vector<uint>& frequencies) {
    if (alphabet.size() != frequencies.size())
        throw std::length_error("Length of alphabet and frequency vectors do not match.");
    std::vector<HuffmanNode*> temp;
    std::queue<HuffmanNode*> newNodes;
    std::queue<HuffmanNode*> generatedNodes;
    for (uint i = 0; i < alphabet.size(); ++i)
        temp.push_back(initNode(alphabet.at(i), frequencies.at(i)));

    std::sort(temp.begin(), temp.end(), NodeSmaller()); 

    for (uint i = 0; i < alphabet.size(); ++i)
        newNodes.push(temp.at(i));
    while (newNodes.size() + generatedNodes.size() > 1) {
        HuffmanNode* node1 = takeMin(newNodes, generatedNodes);
        HuffmanNode* node2 = takeMin(newNodes, generatedNodes);
        HuffmanNode* generatedNode = generateNode(node1, node2);
        generatedNodes.push(generatedNode);
    }
    root = generatedNodes.front();
    std::string s;
    generateSymbolMap(root, s);
}

//-----------------------------------------------------------------------------
// Frees the memory taken by the Huffman Tree
//
// INPUT
// N/A
//
// RETURN VALUE
// N/A
//
// SIDE-EFFECTS
// Any memory allocated for this instantiation of the Huffman Tree will be
// freed.
//-----------------------------------------------------------------------------
HuffmanTree::~HuffmanTree() {
    destructorHelper(root);
}

//-----------------------------------------------------------------------------
// Initializes a Huffman Node.
//
// INPUT
// symbol: A character symbol of the alphabet used
// frequency: The frequency of the symbol in the alphabet
//
// RETURN VALUE
// newNode: The newly created Huffman Node.
// 
// SIDE-EFFECTS
// N/A
//-----------------------------------------------------------------------------
HuffmanNode* HuffmanTree::initNode(char symbol, uint frequency) const{
    HuffmanNode* newNode = new HuffmanNode();
    newNode->frequency = frequency;
    newNode->symbol = symbol;
    newNode->left = 0;
    newNode->right = 0;
    return newNode;
}

//-----------------------------------------------------------------------------
// Takes the minimum frequency value from the front of two queues of Huffman
// Nodes. The Huffman Node that is taken is removed from the queue it is taken 
// from.
// If both queues are empty, this function throws a length_error exception. 
//
// INPUT
// newNodes: A queue that holds nodes that are untouched.
// generatedNodes: A queue that holds nodes generated by combining two nodes.
//
// RETURN VALUE
// takenNode: The Huffman Node that is taken from a queue.
// SIDE-EFFECTS
// N/A
//-----------------------------------------------------------------------------
HuffmanNode* HuffmanTree::takeMin(std::queue<HuffmanNode*>& newNodes,
                                  std::queue<HuffmanNode*>& generatedNodes) const {
    if (newNodes.empty() && generatedNodes.empty())
        throw std::length_error("Expected one value in at least one queue");
    HuffmanNode* takenNode;
    if (generatedNodes.empty() || (!newNodes.empty() &&  
        newNodes.front()->frequency < generatedNodes.front()->frequency)) {
        takenNode = newNodes.front();
        newNodes.pop();
    }
    else {
        takenNode = generatedNodes.front();
        generatedNodes.pop();
    }
    return takenNode;
}

//-----------------------------------------------------------------------------
// Generates a new Huffman Node that has the combined frequency of the the two
// input Huffman Nodes. The symbol for this node NULL because it is not part
// of the alphabet. The left child is the first Huffman Node, the right child
// is the second Huffman Node.
//
// INPUT
// node1: The first Huffman Node.
// node2: The second Huffman Node.
//
// RETURN VALUE
// generatedNode: The Huffman Node generated.
//
// SIDE-EFFECTS
// N/A
//-----------------------------------------------------------------------------
HuffmanNode* HuffmanTree::generateNode(HuffmanNode* node1, 
                                       HuffmanNode* node2) const {
    HuffmanNode* generatedNode = initNode(0, node1->frequency +
                                             node2->frequency);
    generatedNode->left = node1;
    generatedNode->right = node2; 
    return generatedNode;
}

//-----------------------------------------------------------------------------
// Recursively generates a symbol to bit-wise encoding mapping of the Huffman 
// Tree. 
//
// INPUT
// root: The root of the Huffman Tree or subtree.
// curEncoding: The encoding string for the currently visited node.
//
// RETURN VALUE
// N/A
// 
// SIDE-EFFECTS
// The member variable symbolMap will be populated by the mapping generated.
//-----------------------------------------------------------------------------
void HuffmanTree::generateSymbolMap(const HuffmanNode* root, 
                                    std::string& curEncoding) {
    if (root == NULL) return;
    if (root->symbol == 0) {
        curEncoding.push_back('0');
        generateSymbolMap(root->left, curEncoding);
        curEncoding.pop_back();
        curEncoding.push_back('1');
        generateSymbolMap(root->right, curEncoding);
        curEncoding.pop_back();
        return;
    }
    std::pair<char, std::string> encoding = std::make_pair(root->symbol,
                                                           curEncoding);
    symbolMap.push_back(encoding);
}

//-----------------------------------------------------------------------------
// Recursively deletes the nodes in the Huffman Tree
//
// INPUT
// root: The root of the Huffman Tree or subtree.
//
// RETURN VALUE
// N/A
//
// SIDE-EFFECTS
// After this member function has finished all nodes of the Huffman Tree will
// be freed from memory. 
//-----------------------------------------------------------------------------
void HuffmanTree::destructorHelper(HuffmanNode* root) {
    if (root == NULL) return;
    destructorHelper(root->left);
    destructorHelper(root->right);
    delete root;
}

//-----------------------------------------------------------------------------
// Friend function of the Huffman Tree to make it compatible with the ostream
// object. 
//
// INPUT
// os: The ostream that we want to output the Huffman Tree to.
// ht: The Huffman Tree we want to output
//
// RETURN VALUE
// os: The ostream that we want to output the Huffman Tree to.
//
// SIDE-EFFECTS
// The input ostream's buffer will now hold a representation of the symbolMap
// member variable of the input Huffman Tree.
//-----------------------------------------------------------------------------
std::ostream& operator<<(std::ostream& os, const HuffmanTree& ht) {
    for (int i = 0; i < ht.symbolMap.size(); ++i) {
        os << ht.symbolMap.at(i).first << ": ";
        os << ht.symbolMap.at(i).second << std::endl;
    }
    return os;
}

